import * as env from "./env/index";
import * as cronParser from "cron-parser";
import moment from "moment";
import { Instance } from "aws-toolbox/dist/src/ec2";
import * as _ from "lodash";

/**
 * momentインスタンスを 2020-12-31T23:59:59+09:00 の形式でフォーマットする
 * @param dateTime
 */
export const formatMomentToLocalTime = (dateTime: moment.Moment): string => {
  return dateTime.utcOffset(env.utfOffset).format("YYYY-MM-DD[T]HH:mm:ssZ");
};

type generateAmiInfoResultType = {
  /**
   * AMIに設定する名前（Nameタグではない）。「AutoGeneratedAMI～」、ASCII文字だけ
   */
  amiName: string;

  /**
   * AMIの説明(description)。ASCII文字だけ
   */
  description: string;

  /**
   * Nameタグに設定する文字列。「【自動設生成MI】～」
   */
  nameJp: string;

  /**
   * AMIの有効期限。書式はYYYY-MM-DD
   */
  expiresAt: string;
};

/**
 * EC2インスタンスを受け取り、そのタグ情報からAMIに付与する名前やタグ情報を返す
 * @param instance
 * @param forceToReboot
 */
export const generateAmiInfo = (instance: Instance, forceToReboot: boolean): generateAmiInfoResultType => {
  // AMIのdescription（ASCII文字のみ）およびNameタグ（こちらは日本語）
  const description = `auto generated AMI, instance id: ${instance.InstanceId}, no-reboot: ${!forceToReboot}`;
  const nameJp = `【自動生成AMI】${instance.NameTag}(${instance.InstanceId}), 強制リブート: ${
    forceToReboot ? "する" : "しない"
  }`;

  // AMIの寿命を決める
  let amiLifetimeInDays = 30;
  const tagValue = +instance.Tag["AmiLifetimeInDays"];
  if (tagValue === tagValue) {
    amiLifetimeInDays = tagValue;
  }
  if (amiLifetimeInDays <= 1) {
    amiLifetimeInDays = 30;
  }

  // 日付
  const createdAt = moment()
    .utcOffset(env.utfOffset)
    .format("YYYYMMDD_HHmm");
  const expiresAt = moment()
    .utcOffset(env.utfOffset)
    .add(amiLifetimeInDays, "days")
    .format("YYYY-MM-DD");

  // 名前
  // AMIの名前の先頭部分は「nameAsciiタグの値」「それが空文字だったらnameタグから使用不能な文字を取り去ったもの」
  const amiNamePrefix = (instance.Tag["NameAscii"] || instance.NameTag).replace(/[^a-z0-9_]/gi, "");
  const amiName = `AutoGeneratedAMI_${amiNamePrefix}_${createdAt}_${instance.InstanceId}`;

  return { amiName, description, nameJp, expiresAt };
};

/**
 * 文字列として渡された日付をチェックする。その日が来ていればtrue（当日を含む）、それ以外（まだその日が来ていないか、日付としてパースできない）ならfalse
 * @param expiresAt 2020-12-31のような書式の日付。日本時間として解釈される
 * @param now 判定基準となる現在時刻を明示的に指定する
 */
export const isExpired = (expiresAt: string, now?: moment.Moment): boolean => {
  if (expiresAt === "") {
    return false;
  }
  if (!/^20\d\d[-/]\d\d[-/]\d\d$/.test(expiresAt)) {
    return false;
  }
  try {
    const date = moment(expiresAt + "T00:00:00+09:00");
    now = now || moment();
    return date.diff(now) <= 0;
  } catch (e) {
    return false;
  }
};

/**
 * 与えられた文字列をcron形式でパースしてみる。
 * パース可能であり、かつそれが1日3回以下（次の24時間で3回以下）であればtrueを、そうでなければfalseを返す。
 */
export const validateCronExpression = (cronExpression: string | undefined | null): boolean => {
  if (cronExpression === undefined || cronExpression === null) {
    return false;
  }
  try {
    const tomorrow = moment().add(24 * 3600, "second");
    const options = {
      currentDate: new Date(), // 今
      endDate: tomorrow.toDate(),
      iterator: true,
      tz: "Asia/Tokyo"
    };
    const interval = cronParser.parseExpression(cronExpression, options);
    for (let i = 0; i < 3; i++) {
      if (!interval.hasNext()) {
        return true;
      } // 0回目（24時間以内には実行されない）、1回目、2回目で尽きたらOK
      interval.next();
    }
    return !interval.hasNext(); // 3回目でまだ尽きていない=hasNext()がtrueを返すなら多すぎるのでfalse
  } catch (e) {
    return false;
  }
};

/**
 * 与えられた文字列が validateCronExpression() のチェックを通ることを前提に、【基準日時】から直近25時間のスケジュールを返す
 * @param cronExpression cron
 * @param hours スケジュールを返す範囲を時間で指定する
 * @param now 【基準日時】を指定する
 * @returns スケジュール（momentインスタンスの配列）
 */
export const generateInterval = (cronExpression: string, hours: number, now: moment.Moment): moment.Moment[] => {
  if (cronExpression === "") {
    return [];
  }
  const result: moment.Moment[] = [];
  const end = now.clone();
  end.add(hours, "hours");
  const options = {
    currentDate: now.toDate(),
    endDate: end.toDate(),
    iterator: true,
    tz: "Asia/Tokyo"
  };

  const interval = cronParser.parseExpression(cronExpression, options);
  while (interval.hasNext()) {
    const dateStr = (interval.next() as any).value.toISOString();
    result.push(moment(dateStr));
  }

  return result;
};

/**
 * 与えたインスタンスとタグ名からタスクを生成する。何もすることがなければ空の配列を返す
 * @param instance インスタンス
 * @param tagName "AutoStopSchedule"など
 * @param taskName
 * @param hours タスクを生成する範囲（時間）
 * @param now タスクを生成する基準となる日時
 */
export function generateTask<TaskName>(
  instance: Instance,
  tagName: string,
  taskName: TaskName,
  hours: number,
  now: moment.Moment
): {
  instanceId: string;
  task: TaskName;
  schedule: moment.Moment;
}[] {
  if (!validateCronExpression(instance.Tag[tagName])) {
    return [];
  }
  return generateInterval(instance.Tag[tagName], hours, now).map(schedule => {
    return {
      instanceId: instance.InstanceId,
      task: taskName,
      schedule: schedule
    };
  });
}

/**
 * AutoStartScheduleとAutoStopScheduleタグの値から、指定した時点でそのインスタンスは停止しているべきか起動しているべきかを返す
 * @param startSchedule AutoStartScheduleタグの値（未設定ならundefined）
 * @param stopSchedule AutoStopScheduleタグの値（未設定ならundefined）
 * @param now
 */
export const getScheduledStatus = (
  startSchedule: string | undefined,
  stopSchedule: string | undefined,
  now: moment.Moment
): "STOPPED" | "RUNNING" | undefined => {
  // どちらも定義されていなければ常時起動
  if (startSchedule === undefined && stopSchedule === undefined) {
    return "RUNNING";
  }

  // どちらかだけ定義されていれば判定なし
  if (startSchedule === undefined || stopSchedule === undefined) {
    return undefined;
  }

  // cron書式（と回数）チェックを行う。どちらか通らなければ判定なし
  if (!validateCronExpression(startSchedule) || !validateCronExpression(stopSchedule)) {
    return undefined;
  }

  // これでAutoStartScheduleとAutoStopScheduleの両方が設定されていることが確実になった
  const from = moment(now).add(-7, "days");

  const lastStart = _.last(generateInterval(startSchedule, 7 * 24, from));
  const lastStop = _.last(generateInterval(stopSchedule, 7 * 24, from));

  if (lastStart === undefined && lastStop === undefined) {
    return undefined;
  }

  if (lastStart === undefined) {
    return "STOPPED";
  }
  if (lastStop === undefined) {
    return "RUNNING";
  }

  const diff = lastStart.diff(lastStop);
  if (diff > 0) {
    // 最後の起動時間の方が後
    return "RUNNING";
  } else if (diff === 0) {
    return undefined;
  } else {
    return "STOPPED";
  }
};
